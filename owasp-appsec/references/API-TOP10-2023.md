# OWASP API Security Top 10:2023

API-specific security risks with REST and GraphQL examples.

---

## API1:2023 - Broken Object Level Authorization (BOLA)

**Impact**: Access to other users' data by manipulating object identifiers.

### Attack Scenarios
```
# REST: Change ID in path
GET /api/users/123/orders  →  GET /api/users/456/orders

# REST: Change ID in body
POST /api/transfer {"from": "my-account", "to": "attacker"}
  →  {"from": "victim-account", "to": "attacker"}

# GraphQL: Change ID in variable
query { user(id: "victim-id") { email, ssn } }
```

### Detection Patterns
```
# Look for:
- Object IDs from request used directly without ownership check
- No authorization middleware before data access
- Sequential/predictable IDs (123, 124, 125)
- GraphQL resolvers without auth checks
```

### Prevention
- Check user has permission to access specific object in every endpoint
- Use random, unpredictable GUIDs instead of sequential IDs
- Implement authorization checks in data access layer
- Write tests specifically for BOLA scenarios

---

## API2:2023 - Broken Authentication

**Impact**: Account takeover, unauthorized access.

### Attack Scenarios
```
# Credential stuffing - no rate limiting
POST /api/login {"email": "user@example.com", "password": "password1"}
POST /api/login {"email": "user@example.com", "password": "password2"}
... (thousands of attempts)

# Weak JWT validation
Authorization: Bearer <token-with-alg:none>

# Password reset token in URL (logged, cached)
GET /api/reset-password?token=abc123
```

### Detection Patterns
```
# Look for:
- Missing rate limiting on auth endpoints
- JWT signature not verified or algorithm not restricted
- Long-lived or non-expiring tokens
- Sensitive tokens in URLs
- Missing account lockout after failed attempts
```

### Prevention
- Implement rate limiting and account lockout
- Use strong JWT libraries, restrict allowed algorithms
- Short-lived access tokens with refresh token rotation
- Never expose tokens in URLs
- Implement MFA for sensitive operations

---

## API3:2023 - Broken Object Property Level Authorization

**Impact**: Exposure of sensitive properties or unauthorized property modification.

### Attack Scenarios
```
# Mass assignment - setting admin flag
POST /api/users {"name": "John", "email": "john@test.com", "isAdmin": true}

# Excessive data exposure
GET /api/users/123
Response: {"id": 123, "name": "John", "ssn": "123-45-6789", "salary": 100000}

# GraphQL over-fetching
query { user(id: "123") { name, email, password, ssn, creditCard } }
```

### Detection Patterns
```
# Look for:
- Request body bound directly to model (auto-binding)
- All model properties returned in responses
- No allowlist of writable/readable properties
- GraphQL types exposing sensitive fields
```

### Prevention
- Define explicit allowlists for input properties per endpoint
- Return only required properties in responses (use DTOs)
- Never auto-bind request to internal models
- Restrict GraphQL schema to expose only intended fields

---

## API4:2023 - Unrestricted Resource Consumption

**Impact**: Denial of service, cost explosion in cloud environments.

### Attack Scenarios
```
# Unbounded list queries
GET /api/users?limit=1000000

# GraphQL complexity bomb
query { users { friends { friends { friends { posts { comments } } } } } }

# Large file upload
POST /api/upload (10GB file)

# Regex DoS
POST /api/search {"pattern": "(a+)+$", "text": "aaaaaaaaaaaaaaaaaX"}
```

### Detection Patterns
```
# Look for:
- Missing pagination limits or max values
- No request size limits
- GraphQL without query depth/complexity limits
- Expensive operations without rate limiting
- Regex on user input without timeout
```

### Prevention
- Implement and enforce pagination limits
- Set maximum request body size
- GraphQL: limit query depth, complexity, and field count
- Rate limit expensive operations
- Set timeouts for all operations
- Validate and limit file upload sizes

---

## API5:2023 - Broken Function Level Authorization (BFLA)

**Impact**: Users accessing admin or privileged functions.

### Attack Scenarios
```
# Accessing admin endpoints
GET /api/admin/users (as regular user)

# HTTP method manipulation
GET /api/users/123 → allowed
DELETE /api/users/123 → should be denied but isn't

# Path manipulation
/api/users/settings → /api/admin/settings
```

### Detection Patterns
```
# Look for:
- Missing role checks on admin endpoints
- Inconsistent authorization across HTTP methods
- Authorization only checked on some endpoints
- Admin paths guessable from user paths
```

### Prevention
- Deny all by default, explicitly grant access
- Review authorization for every endpoint and HTTP method
- Implement role-based access control centrally
- Use different authentication for admin APIs when possible

---

## API6:2023 - Unrestricted Access to Sensitive Business Flows

**Impact**: Automated abuse of legitimate functionality.

### Attack Scenarios
```
# Ticket scalping - automated bulk purchase
for i in range(1000):
    POST /api/tickets/purchase {"event": "concert", "qty": 10}

# Referral abuse
for email in generated_emails:
    POST /api/referral {"referrer": "attacker", "referee": email}

# Comment spam
for _ in range(10000):
    POST /api/comments {"text": "Buy cheap..."}
```

### Detection Patterns
```
# Look for:
- High-value operations without abuse protection
- No rate limiting per user on business flows
- Missing CAPTCHA on sensitive operations
- No device fingerprinting or behavioral analysis
```

### Prevention
- Identify sensitive business flows (purchase, signup, etc.)
- Implement device fingerprinting
- Add CAPTCHA for automated abuse prevention
- Rate limit per user, not just per IP
- Monitor for unusual patterns (velocity checks)

---

## API7:2023 - Server Side Request Forgery (SSRF)

**Impact**: Access to internal services, cloud metadata, or remote code execution.

### Attack Scenarios
```
# Fetching internal services
POST /api/fetch-url {"url": "http://localhost:8080/admin"}

# Cloud metadata theft (AWS)
POST /api/fetch-url {"url": "http://169.254.169.254/latest/meta-data/"}

# Port scanning
POST /api/fetch-url {"url": "http://internal-host:22"}
```

### Detection Patterns
```
# Look for:
- User-provided URLs passed to HTTP client
- URL validation only checking protocol (http/https)
- No URL allowlist for external requests
- Redirects followed automatically
```

### Prevention
- Allowlist permitted URLs/domains for external requests
- Disable HTTP redirects or validate redirect destinations
- Block requests to private IP ranges (10.x, 172.16.x, 192.168.x, 169.254.x)
- Use network segmentation to limit API server reach
- Don't return raw responses from fetched URLs

---

## API8:2023 - Security Misconfiguration

**Impact**: Information disclosure, unauthorized access through misconfigurations.

### Attack Scenarios
```
# CORS misconfiguration
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true

# Missing security headers
(No CSP, HSTS, X-Content-Type-Options)

# Debug mode in production
GET /api/debug/routes
{"routes": [...all internal routes...]}
```

### Detection Patterns
```
# Look for:
- Permissive CORS (wildcard origin with credentials)
- Missing security headers
- Verbose error messages with stack traces
- Debug/test endpoints accessible
- Default credentials
- Unnecessary HTTP methods enabled
```

### Prevention
- Harden CORS: explicit origin allowlist, no credentials with wildcards
- Add security headers: CSP, HSTS, X-Content-Type-Options
- Disable debug endpoints in production
- Remove default credentials
- Automated configuration scanning in CI/CD

---

## API9:2023 - Improper Inventory Management

**Impact**: Attacks via undocumented or deprecated endpoints.

### Attack Scenarios
```
# Deprecated endpoint still accessible
/api/v1/users (old, vulnerable) still works alongside /api/v2/users

# Undocumented admin endpoint
/api/internal/admin (not in docs, no auth)

# Debug endpoint left in production
/api/debug/dump-db
```

### Detection Patterns
```
# Look for:
- Multiple API versions without deprecation plan
- Endpoints not in official documentation
- Test/staging endpoints accessible in production
- No API inventory or registry
```

### Prevention
- Maintain inventory of all API hosts and versions
- Document all endpoints, including internal ones
- Implement API versioning with sunset dates
- Remove deprecated versions after transition period
- Generate documentation from code (OpenAPI)
- Regular audit to find undocumented endpoints

---

## API10:2023 - Unsafe Consumption of APIs

**Impact**: Attacks via trusted third-party APIs.

### Attack Scenarios
```
# Trusting third-party response
third_party_response = fetch(external_api)
db.query(f"SELECT * FROM users WHERE id = {third_party_response.id}")  # Injection!

# Following redirects to malicious sites
http_client.get(user_provided_url, follow_redirects=True)

# No timeout on third-party calls
response = requests.get(slow_third_party)  # Hangs forever
```

### Detection Patterns
```
# Look for:
- Third-party responses used without validation
- Unlimited redirects followed
- No timeout on external API calls
- Third-party data used in queries/commands
- No integrity verification of third-party data
```

### Prevention
- Validate and sanitize all third-party responses
- Evaluate security posture of third-party integrations
- Ensure encrypted communication with third parties (TLS)
- Set timeouts and limits on external requests
- Don't blindly follow redirects
- Treat third-party data as untrusted input